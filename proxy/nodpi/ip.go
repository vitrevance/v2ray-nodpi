package nodpi

import (
	"net"
	"slices"
	"syscall"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
)

type ConnOptions struct {
	srcIP   net.IP
	dstIP   net.IP
	srcPort uint16
	dstPort uint16
}

type Connection struct {
	ConnOptions
	// ipConn   net.PacketConn
	tcpConn  net.Conn
	sequence uint32
	rawFD    int
}

func GetLocalIP() (net.IP, error) {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		return nil, err
	}
	for _, address := range addrs {
		// check the address type and if it is not a loopback the display it
		if ipnet, ok := address.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
			if ipnet.IP.To4() != nil {
				return ipnet.IP, nil
			}
		}
	}
	return nil, newError("local IP not found")
}

func GetFreePort() (port int, err error) {
	var a *net.TCPAddr
	if a, err = net.ResolveTCPAddr("tcp", "localhost:0"); err == nil {
		var l *net.TCPListener
		if l, err = net.ListenTCP("tcp", a); err == nil {
			defer l.Close()
			return l.Addr().(*net.TCPAddr).Port, nil
		}
	}
	return
}

func WrapTCPConn(under net.Conn) (*Connection, error) {
	conn := &Connection{}

	fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_RAW, syscall.IPPROTO_RAW)
	if err != nil {
		return nil, err
	}
	if err := syscall.SetsockoptInt(fd, syscall.IPPROTO_IP, syscall.IP_HDRINCL, 1); err != nil {
		return nil, newError("Failed to set IP_HDRINCL").Base(err)
	}

	conn.rawFD = fd

	conn.srcIP = under.LocalAddr().(*net.TCPAddr).IP
	conn.srcPort = uint16(under.LocalAddr().(*net.TCPAddr).Port)
	conn.dstIP = under.RemoteAddr().(*net.TCPAddr).IP
	conn.dstPort = uint16(under.RemoteAddr().(*net.TCPAddr).Port)

	conn.tcpConn = under

	conn.sequence = 1

	// ipConn, err := net.DialIP("ip4:tcp", &net.IPAddr{
	// 	IP: conn.srcIP,
	// }, &net.IPAddr{
	// 	IP: conn.dstIP,
	// })

	return conn, nil
}

// func NewTCPConn(address *net.TCPAddr) (*Connection, error) {
// 	freePort, err := GetFreePort()
// 	if err != nil {
// 		return nil, err
// 	}
// 	ipConn, err := net.ListenIP("ipv4", &net.IPAddr{
// 		IP: net.IPv4(127, 0, 0, 100),
// 	})
// 	if err != nil {
// 		return nil, err
// 	}
// 	conn := &Connection{ipConn: ipConn}
// 	conn.srcIP = net.IPv4(0, 0, 0, 0)
// 	conn.srcPort = uint16(freePort)
// 	conn.dstIP = address.IP
// 	conn.dstPort = uint16(address.Port)

// 	tcpConn, err := net.DialTCP("tcp", &net.TCPAddr{
// 		IP:   conn.srcIP,
// 		Port: int(conn.srcPort),
// 	}, &net.TCPAddr{
// 		IP:   conn.dstIP,
// 		Port: int(conn.dstPort),
// 	})
// 	if err != nil {
// 		ipConn.Close()
// 		return nil, err
// 	}
// 	conn.tcpConn = tcpConn
// 	return conn, nil
// }

func (c *Connection) WritePacket(p []byte) error {
	// return c.ipConn.WriteTo(p, &net.IPAddr{
	// 	IP: c.dstIP,
	// })
	err := syscall.Sendto(c.rawFD, p, 0, &syscall.SockaddrInet4{
		Addr: [4]byte(c.dstIP),
	})
	return err
}

type PreparedPacket struct {
	ip      *layers.IPv4
	tcp     *layers.TCP
	payload gopacket.Payload
}

func (c *Connection) SerialziePacket(p *PreparedPacket, opts gopacket.SerializeOptions) ([]byte, error) {
	buf := gopacket.NewSerializeBuffer()
	err := gopacket.SerializeLayers(buf, opts, p.ip, p.tcp, p.payload)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (c *Connection) PreparePacket(payload []byte) *PreparedPacket {
	ip := &layers.IPv4{
		Version:  4,
		Protocol: layers.IPProtocolTCP,
		TTL:      128,
		DstIP:    c.dstIP,
		SrcIP:    c.srcIP,
	}
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(c.srcPort),
		DstPort: layers.TCPPort(c.dstPort),
		Seq:     c.sequence,
		Ack:     0,
		ACK:     false,
		SYN:     false,
		FIN:     false,
		RST:     false,
		URG:     false,
		ECE:     false,
		CWR:     false,
		NS:      false,
		PSH:     false,
		Window:  14600,
	}
	c.sequence++
	tcp.SetNetworkLayerForChecksum(ip)
	return &PreparedPacket{
		ip:      ip,
		tcp:     tcp,
		payload: payload,
	}
}

func (c *Connection) Write(tcpPayload []byte) (int, error) {
	// p := c.PreparePacket(tcpPayload)
	// b, err := c.SerialziePacket(p, gopacket.SerializeOptions{FixLengths: true, ComputeChecksums: true})
	// if err != nil {
	// 	return 0, err
	// }
	// return c.WritePacket(b)
	c.sequence++
	return c.tcpConn.Write(tcpPayload)
}

func (c *Connection) Read(buffer []byte) (int, error) {
	size, err := c.tcpConn.Read(buffer)
	return size, err
}

func (c *Connection) Close() error {
	// c.ipConn.Close()
	syscall.Close(c.rawFD)
	return c.tcpConn.Close()
}

func (c *Connection) LocalAddr() net.Addr {
	return c.tcpConn.LocalAddr()
}

func (c *Connection) RemoteAddr() net.Addr {
	return c.tcpConn.RemoteAddr()
}

func (c *Connection) SetDeadline(t time.Time) error {
	return c.tcpConn.SetDeadline(t)
}

func (c *Connection) SetReadDeadline(t time.Time) error {
	return c.tcpConn.SetReadDeadline(t)
}

func (c *Connection) SetWriteDeadline(t time.Time) error {
	return c.tcpConn.SetWriteDeadline(t)
}

func SendReverseOrder(conn *Connection, payloads ...[]byte) error {
	packs := make([]*PreparedPacket, 0)
	for _, load := range payloads {
		packs = append(packs, conn.PreparePacket(load))
	}
	slices.Reverse(packs)
	for _, p := range packs {
		b, err := conn.SerialziePacket(p, gopacket.SerializeOptions{FixLengths: true, ComputeChecksums: true})
		if err != nil {
			return err
		}
		err = conn.WritePacket(b)
		if err != nil {
			return err
		}
	}
	return nil
}

var FakeHTTPSPayload = []byte{0x16, 0x03, 0x01, 0x02, 0x00, 0x01, 0x00, 0x01, 0xfc, 0x03, 0x03, 0x9a, 0x8f, 0xa7, 0x6a, 0x5d,
	0x57, 0xf3, 0x62, 0x19, 0xbe, 0x46, 0x82, 0x45, 0xe2, 0x59, 0x5c, 0xb4, 0x48, 0x31, 0x12, 0x15,
	0x14, 0x79, 0x2c, 0xaa, 0xcd, 0xea, 0xda, 0xf0, 0xe1, 0xfd, 0xbb, 0x20, 0xf4, 0x83, 0x2a, 0x94,
	0xf1, 0x48, 0x3b, 0x9d, 0xb6, 0x74, 0xba, 0x3c, 0x81, 0x63, 0xbc, 0x18, 0xcc, 0x14, 0x45, 0x57,
	0x6c, 0x80, 0xf9, 0x25, 0xcf, 0x9c, 0x86, 0x60, 0x50, 0x31, 0x2e, 0xe9, 0x00, 0x22, 0x13, 0x01,
	0x13, 0x03, 0x13, 0x02, 0xc0, 0x2b, 0xc0, 0x2f, 0xcc, 0xa9, 0xcc, 0xa8, 0xc0, 0x2c, 0xc0, 0x30,
	0xc0, 0x0a, 0xc0, 0x09, 0xc0, 0x13, 0xc0, 0x14, 0x00, 0x33, 0x00, 0x39, 0x00, 0x2f, 0x00, 0x35,
	0x01, 0x00, 0x01, 0x91, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x0d, 0x00, 0x00, 0x0a, 0x77, 0x77, 0x77,
	0x2e, 0x77, 0x33, 0x2e, 0x6f, 0x72, 0x67, 0x00, 0x17, 0x00, 0x00, 0xff, 0x01, 0x00, 0x01, 0x00,
	0x00, 0x0a, 0x00, 0x0e, 0x00, 0x0c, 0x00, 0x1d, 0x00, 0x17, 0x00, 0x18, 0x00, 0x19, 0x01, 0x00,
	0x01, 0x01, 0x00, 0x0b, 0x00, 0x02, 0x01, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0e,
	0x00, 0x0c, 0x02, 0x68, 0x32, 0x08, 0x68, 0x74, 0x74, 0x70, 0x2f, 0x31, 0x2e, 0x31, 0x00, 0x05,
	0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x6b, 0x00, 0x69, 0x00, 0x1d, 0x00,
	0x20, 0xb0, 0xe4, 0xda, 0x34, 0xb4, 0x29, 0x8d, 0xd3, 0x5c, 0x70, 0xd3, 0xbe, 0xe8, 0xa7, 0x2a,
	0x6b, 0xe4, 0x11, 0x19, 0x8b, 0x18, 0x9d, 0x83, 0x9a, 0x49, 0x7c, 0x83, 0x7f, 0xa9, 0x03, 0x8c,
	0x3c, 0x00, 0x17, 0x00, 0x41, 0x04, 0x4c, 0x04, 0xa4, 0x71, 0x4c, 0x49, 0x75, 0x55, 0xd1, 0x18,
	0x1e, 0x22, 0x62, 0x19, 0x53, 0x00, 0xde, 0x74, 0x2f, 0xb3, 0xde, 0x13, 0x54, 0xe6, 0x78, 0x07,
	0x94, 0x55, 0x0e, 0xb2, 0x6c, 0xb0, 0x03, 0xee, 0x79, 0xa9, 0x96, 0x1e, 0x0e, 0x98, 0x17, 0x78,
	0x24, 0x44, 0x0c, 0x88, 0x80, 0x06, 0x8b, 0xd4, 0x80, 0xbf, 0x67, 0x7c, 0x37, 0x6a, 0x5b, 0x46,
	0x4c, 0xa7, 0x98, 0x6f, 0xb9, 0x22, 0x00, 0x2b, 0x00, 0x09, 0x08, 0x03, 0x04, 0x03, 0x03, 0x03,
	0x02, 0x03, 0x01, 0x00, 0x0d, 0x00, 0x18, 0x00, 0x16, 0x04, 0x03, 0x05, 0x03, 0x06, 0x03, 0x08,
	0x04, 0x08, 0x05, 0x08, 0x06, 0x04, 0x01, 0x05, 0x01, 0x06, 0x01, 0x02, 0x03, 0x02, 0x01, 0x00,
	0x2d, 0x00, 0x02, 0x01, 0x01, 0x00, 0x1c, 0x00, 0x02, 0x40, 0x01, 0x00, 0x15, 0x00, 0x96, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00}

func (conn *Connection) SendFakeHTTPS() error {
	p := conn.PreparePacket(FakeHTTPSPayload)
	p.tcp.SYN = true
	p.tcp.ACK = true
	p.tcp.PSH = true
	p.tcp.Ack = 1
	p.tcp.Seq = ^uint32(0)
	b, err := conn.SerialziePacket(p, gopacket.SerializeOptions{FixLengths: true, ComputeChecksums: true})
	if err != nil {
		return err
	}
	err = conn.WritePacket(b)
	return err
}
